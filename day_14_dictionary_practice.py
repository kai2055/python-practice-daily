# -*- coding: utf-8 -*-
"""day_14_dictionary_practice.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1t1C3f6vyIBR0XGH8LapuzsOsTDsR6YOy
"""

# Create a dictionary from two lists

keys = ['name', 'age', 'city']
values = ['Alice', 25, 'NYC']

def dictionary_creator(lst1, lst2):
  my_dictionary = {}

  for i in range(len(lst1)):
    my_dictionary[lst1[i]] = lst2[i]

  return my_dictionary


print(dictionary_creator(keys, values))



# Another apporach

def dictionary_creator_v2(lst1, lst2):
  my_dictionary = dict(zip(keys, values))

  return my_dictionary

print(dictionary_creator(keys, values))

# Above program with edge case handling

key_list = ['name', 'age', 'city']
value_list = ['nikhil', 26, 'berlin']


def dictionary_creator(lst1, lst2):

  # Edge case 1: Empty lists
  if not lst1 and not lst2:
    print("Both lists are empty - returning empty dictionary")
    return {}

  # Edge case 2: One list is empty
  if not lst1 or not lst2:
    print("One list is empty but the other is not - returning error message")
    return {"error": "One list is empty while the other has data"}


  # Edge case 3: Lists of different lengths
  if len(lst1) != len(lst2):
    print(f"Lists have different lengths - Keys: {len(lst1)} Values: {len(lst2)}")
    print("Using the shorter length to avoid index errors")

  # Use the minimum length to prevent IndexError
  min_length = min(len(lst1), len(lst2))
  my_dictionary = {}

  for i in range(min_length):
    my_dictionary[lst1[i]] = lst2[i]
    print(f"Added: {lst1[i]} = {lst2[i]}")


  return my_dictionary


print(dictionary_creator(key_list, value_list))

# Add/update/delete operations

user = {'name': 'NIKHIL', 'age': 26}
print(user)
user["email"] = "nikhiladhikari1@gmail.com"
user["age"] = 27
print(user)

del user['age']
print(user)

# safe dictionary access

data = {'name': 'Charlie'}

# Get 'name' (exists)
name = data.get('name')
print(name)

# Get 'age' with default value 0 (doesn't exist)
age = data.get('age', 0)
print(age)

# Get 'city' with default 'Unknown'
city = data.get('city', 'unknown')
print(city)

# Check if key exists

config = {'host': 'localhost', 'port': 8080}


def checking_keys(config):
  return_tuple = []

  if 'host' in config:
    print(f"Host: {config['host']}")
    return_tuple.append("host_exists")
  else:
    return_tuple.append("host_doesnot_exist")

  if 'password' in config:
    return_tuple.append("password_exists")
  else:
    return_tuple.append("password_doesnt_exist")

  return tuple(return_tuple)


print(checking_keys(config))

# Get all keys, values, and items

scores = {'math': 90, 'english': 85, 'science': 92}


def count_dictionary_elements(lst1):
  list_of_keys = [key for key in lst1]
  list_of_values = [value for value in lst1.values()]
  list_of_items = [(key, value) for key, value in lst1.items()]

  return list_of_keys, list_of_values, list_of_items


keys, values, items = count_dictionary_elements(scores)
print(keys)
print(values)
print(items)

# Pythonic approach for above code
scores = {'math': 90, 'english': 85, 'science': 92}
def get_dict_elements(dictionary):
  return list(dictionary.keys()), list(dictionary.values()), list(dictionary.items())


keys, values, items = get_dict_elements(scores)
print(keys)
print(values)
print(items)

# Create dictionary from range

dict1 = {x:x*x for x in range(1,5)}

print(dict1)

# Filter dictionary - return only items where price > 1.0

prices = {'apple': 1.2, 'banana': 0.5, 'cherry':3.0,  'date': 2.5}

filtered_fruits = {key: value for key, value in prices.items() if value >= 1}

print(filtered_fruits)

# Transform dictionary values - convert into uppercase

names = {'first': 'Jhon', 'last': 'doe', 'middle': 'james'}
uppercase_name = {key: value.upper() for key, value in names.items()}

print(uppercase_name)

# Invert dictionary (swap keys and values)

codes = {'A': 1, 'B': 2, 'C': 3}

inverted_code = {num:alpha for alpha, num in codes.items()}
print(inverted_code)

# Create dictionary from list with condition


numbers = [1,2,3,4,5,6,7,8,9,10]

even_numbers = {num: 'even' for num in numbers if num % 2 == 0}
print(even_numbers)

# NESTED DICTIONARIES

# Create a student record:

nikhil_profile = {
    'name': 'Nikhil Adhikari',
    'grades': {'math': 90, 'english': 85},
    'contact': {'email': 'nikhiladhikari1@gmail.com', 'phone': 9849365984}

}


print(f"Name: {nikhil_profile['name']}")
print(f"Math grade: {nikhil_profile['grades']['math']}")
print(f"Email: {nikhil_profile['contact']['email']}")
print(f"New Adress: {nikhil_profile.get('new address', 'unknown')}")

# Update nested values

config = {'database': {'host': 'localhost', 'port': 5432},
          'cache': {'enabled': True}}

config['database']['port'] = 3306
config['cache']['timeout'] = 30


print(config)

# Flatten nested dictionary


def flatten_dict(nested_dict, parent_key='', seperator='.'):
  flattened = {}

  for key, value in nested_dict.items():
    # create the new key with dot notation
    new_key = f"{parent_key}{seperator}{key}" if parent_key else key


    if isinstance(value, dict):
      # Recursively flatten nested dictionaries
      flattened.update(flatten_dict(value, new_key, seperator))
    else:
      # Add the first key-value pair
      flattened[new_key] = value

  return flattened


nested_dict = {'a': 1, 'b': {'c': 2, 'd': 3}}
result = flatten_dict(nested_dict)
print("Original:", nested_dict)
print("Flattened:", result)

# Nested Dictionary Visualization

# Real-World Example


# Level 1: Company
# Level 2: Departments
# level 3: Employees
# Level 4: Employee Details

company = {
    'tech_department': {
        'managers': {
            'alice': {
                'salary': 80000,
                'experience': 5,
                'skills': ['Python', 'Java', 'AWS']
            },
            'bob': {
                'salary': 75000,
                'experience': 4,
                'skills': ['Javascript', 'React', 'Node.js']
            }
        },
        'developers': {
            'charlie': {
                'salary': 60000,
                'experience': 2,
                'skills': ['Python', 'Django']
            }
        }
    },
    'hr_department': {
        'recruiters': {
            'diana': {
                'salary': 55000,
                'experience': 3,
                'skills': ['Interviewing', 'Onboarding']
                }
        }
    }
}




# VISUALIZE THIS STRUCTURE
print("=== COMPANY STRUCTURE ===")
print("Level 1 - Departments", list(company.keys()))
print("Level 2 - Teams in Tech", list(company['tech_department'].keys()))
print("Level 3 - Managers in Tech:", list(company['tech_department']['managers'].keys()))
print("level 4 - Alice's Skills: ", company['tech_department']['managers']['alice']['skills'])




print("=" * 50)
print("ITERATING THROUGH NESTED DICT")


# Loop through the structure
for department, teams in company.items():
  print(f"\nDepartment: {department}")
  for team, employees in teams.items():
    print(f" Team: {team}")
    for employee, details in employees.items():
      print(f"    Employee: {employee}")
      print(f"    Salary: {details['salary']}")
      print(f"    Experience: {details['experience']} years")