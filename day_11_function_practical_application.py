# -*- coding: utf-8 -*-
"""day_11_function_practical_application.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1imPJbR3Bur8Jab7YECTNaYG53h0L8Nz5
"""

# Create a data validation function:
# check: contains @, has domain, no spaces



def email_validator(email):
  """
  The function checks whether the given sting is a valid email address or not


  Argument(String):
              - The email address passed to the function


  Return Value:
              - Boolean (True) if the given address is a valid email.
              - Boolen (False) if the given address is not valid email.

  Validation Rules:
              - Contains @ symbol
              - Has domain (text after @ with at least one dot)
              - No spaces

  """


  # Check if email is a string
  if not isinstance(email, str):
    return False

  # Check 1: Contains @
  if '@' not in email:
    return False


  # Check 2: No spaces
  if ' ' in email:
    return False

  # Check 3: Has domain with at least one dot after @
  parts = email.split('@')
  if len(parts) != 2:
    return False


  domain_part = parts[1]
  if '.' not in domain_part:
    return False


  # Additional check: domain should have at least one character before and after the last dot

  domain_parts = domain_part.split('.')
  if len(domain_parts) < 2:
    return False

  if not domain_parts[-1] or not domain_parts[0]:
    return False

  return True




print(email_validator("nikhiladhikari1@gmail.com"))




# Reflection
# Rather than gettin hung up on how previously things were done, try to see what the requirement is
# Gettung fixated on "regular expression" did not let me see that this was more about functions and condition
# Don't just try to take in the whole problem and expect one main solution
# Break it down and do it step by step
# But rather than just thinking force yourself to write the code, no matter what

# Create a string formatter with options.
# uppercase, trim, max_length
# Apply transformation based on options


"""
  Thinking:
      - The string is not to be optional. If left empty it should handle the exception.
      - But the formatting options are optional which means that it has default options.
      - Use keyword arguments with default values so that when the options are not given the function does not crash
"""




def string_formatter(words, uppercase=False, trim=True, max_length=None):
  """
  The function takes a string and formatting option with their values and returns the formatted string

  Arguments:
        - words (string): the string given that needs to be formatted
        - Optinal: - trim(True or False) determines whether the space in the string is to be removed or not
                    - uppercase(True or False) determines if the given string is to be converted to upperscase
                    - max_length (None or int) determines the length of the string to the specified int


  Return Value - formatted_string (string) - as the name suggests

  """

  # Check 1: First i need to check if the given value si string or not
  if not isinstance(words, str):
    return None

  # Check 2:
  if uppercase != False:
    words = words.upper()

  # Check 3:
  if trim == True:
    words = words.strip()
  else:
    words = words

  # Check 4:
  if max_length == None:
    return words
  else:
    return words[:max_length]



print(string_formatter("HelloWorld"))



"""
Reflection:
          - I needed to think about the logical order of the operation
           such as i could have used the trim first and then the length limit in order
           to avoid unnecessary processing such as case conversion
          - Simplifies condition checks



"""

# Improved version of the above code


def string_formatter(words, uppercase=False, trim=True, max_length=None):


  # Check 1: Verify input is a string
  if not isinstance(words, str):
    return None


  # Apply transformations in logical order

  # First: Trim if requested
  if trim:
    words = words.strip()

  # Second: Apply length limit (before case change to avoid unnecessary processing)
  if max_length is not None and max_length >= 0:
    words = words[:max_length]

  # Third: Change case
  if uppercase:
    words = words.upper()


  return words



# Test cases
test_string = "   Hello World!   "

print("Original:", f"'{test_string}'")
print("Trim only:", f"'{string_formatter(test_string)}'")
print("Uppercase only:", f"'{string_formatter(test_string, uppercase=True, trim=False)}'")
print("Trim + Uppercase:", f"'{string_formatter(test_string, uppercase=True)}'")
print("Max length 5:", f"'{string_formatter(test_string, max_length=5)}'")
print("All options:", f"'{string_formatter(test_string, uppercase=True, trim=True, max_length=7)}'")
print("Non-string input:", string_formatter(123))

# Create a list processing function
# options include remove_duplicates, sort, reverse


def list_processer(items, /, remove_duplicates=False, sort=False, reverse=False):

  if remove_duplicates:
    items = list(set(items))

  if sort:
    items.sort()

  if reverse:
    reversed_list = items[:: -1]
    return reversed_list
  else:
    return items



print(list_processer([1,2,3], sort=True, reverse=True))

# improved version

def list_processor(items, /, remove_duplicates=False, sort=False, reverse=False):
  """
  Process a list with various transformation options.

  Args:
      - items: Iterable to process
      - remove_duplicates: remove duplicate items if True
      - sort: sort items if True
      - reverse: reverse order if True

  Returns:
      processed list


  """

  # Create a copy to avoid modifying original
  processed = list(items)

  # Apply operations in logical order
  if remove_duplicates:
    # Preserve order for hashable items
    try:
      seen = set()
      processed = [x for x in processed if not (x in seen or seen.add(x))]
    except TypeError:
      # Fallback for unhashable types
      unique_list = []
      for item in processed:
        if item not in unique_list:
          unique_list.append(item)
      processed = unique_list

  if sort:
    try:
      processed.sort()
    except TypeError:
      # Handle mixed types or unorderable elements
      processed = sorted(processed, key=str)

  if reverse:
    processed = processed[::-1]

  return processed



# Test data
numbers = [3, 1, 4, 1, 5, 9, 2, 6, 5]
strings = ['banana', 'apple', 'cherry', 'apple', 'date']
mixed = [3, 'apple', 1, 'banana', 3, 'apple']

print("=== BASIC USAGE ===")

# 1. Original list (no processing)
print("Original:", list_processor(numbers))
# Output: [3, 1, 4, 1, 5, 9, 2, 6, 5]

# 2. Remove duplicates only
print("Remove duplicates:", list_processor(numbers, remove_duplicates=True))
# Output: [3, 1, 4, 5, 9, 2, 6]