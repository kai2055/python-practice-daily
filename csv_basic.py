# -*- coding: utf-8 -*-
"""csv_basic.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jAexC_TQ8_O0Q1wnXJMmfBBiagBi-g6P
"""

"""
COMPLETE CSV FILES BASICS

This program demostrates everything about CSV (Comma Seperated Values) files:
1. What CSV files are and their characteristics
2. How to load CSV files using different methods
3. How to manipulate and analyze CSV data
4. How to save/export CSV files


"""

# Section 1: CSV File characteristics and overview

"""
What is a CSV File?

CSV stands for "Comma-Seperated Values"
- A plain text file format for storing tabular data
- Each line represents a row of data
- Values in each row are seperated commas (or other delimiters)
- First row often contains column headers
- File extension: .csv


EXAMPLE CSV STRUCTURE:
name,age,city,salary
Jhon,28,New York,75000
Alice,34,San Francisco,95000
Bob,45,Chicago,68000

KEY CHARACTERISTICS:

1. DELIMITER: Character seperating values (usually comma, but can be semicolon,
tab, pipe, etc.)
2. PLAIN TEXT: Human-readable format, can open in any text editor
3. UNIVERSAL: Supported by almost all data tools (Excel, databases, Python, R)
4. NO DATA TYPES: Everything stored as text (you convert during processing)
5. HEADER ROW: First row typically contains column names
6. LIGHTWEIGHT: Small file size compared to Excel or databases
7. NO FORMULAS: Only stores raw data, no calculations or fromatting


ADVANTAGES:

1. Simple and lightweight
2. Easy to read and edit manually
3. Platform-independent
4. Widely supported across tools
5. Fast to process for large databases

LIMITATIONS:

1. No data type prservation (dates, numbers stored as text)
2. No formatting (colors, fonts, etc.)
3. No multiple sheets (like Excel)
4. Special characters can cause issues
5. No built-in data validation


"""

# SECTION 2: Importing required libraries

# Standard library - built into python
import csv # Basic CSV operations

# Pandas - most powerful library for data manipulation (needs installation)
import pandas as pd

# For creating sample data
from io import StringIO
import os


print("=" * 80)
print("CSV FILES BASIC - COMPREHENSIVE GUIDE")
print("=" * 80)


# Section 3: Creating Sample CSV DATA

print("\n" + "=" * 80)
print("SECTION 1: Creating Sample CSV Data")
print("=" * 80)

# Create sample CSV content as a string
sample_csv_content = """name,age,city,salary,department
John Smith,28,New York,75000,Engineering
Alice Johnson,34,San Francisco,95000,Data Science
Bob Williams,45,Chicago,68000,Marketing
Emma Davis,29,Boston,82000,Engineering
Michael Brown,38,Seattle,91000,Data Science
Sarah Wilson,31,Austin,77000,Marketing
David Lee,42,Denver,88000,Engineering"""


# Save to a file
with open('employees.csv', 'w') as f:
  f.write(sample_csv_content)

print("Created sample file: employees.csv")
print("\nFile contents:")
print(sample_csv_content)


# Section 4: Method 1 - Reading CSV with built-in csv module

print("\n" + "=" * 80)
print("SECTION 2: Reading CSV - Method 1 (Buile-in csv module)")
print("=" * 80)

"""
The csv module is part of Python's standard library.
It's lightweight and good for simple operations.
"""


# Reading CSV as list of dictionaries (recommended for most cases)
print("\n--- Reading as dictionaries (DictReader) ---")
with open('employees.csv', 'r') as file:
  csv_reader = csv.DictReader(file)

  # DictReader treats first row as headers and creates dict for each row
  print(f"Column names: {csv_reader.fieldnames}")

  employees = list(csv_reader) # Convert to list to store all rows

  # Print first two employees
  for i, employee in enumerate(employees[:2]):
    print(f"\nEmployee {i+1}:")
    for key, value in employee.items():
      print(f" {key}: {value}")


  # Reading csv as list of lists
  print("\n--- Reading as lists (reader) ---")
  with open('employees.csv', 'r') as file:
    csv_reader = csv.reader(file)

    # First row contains headers
    headers = next(csv_reader)
    print(f"Headers: {headers}")


    # Remainig rows are data
    print("\nFirst two data rows:")
    for i in range(2):
      row = next(csv_reader)
      print(f"Row {i+1}: {row}")

# SECTION 5: Method 2 - Reading CSV with Pandas (Most powerful)

print("\n" + "=" * 80)
print("SECTION 3: Reading CSV - Method 2 (Pandas - Recommended)")
print("=" * 80)

"""
Pandas is the industry-standard library for data manipulation.
It provides a DataFrame object - think of it as Excel spreadsheet in Python
"""

# Basic read
df = pd.read_csv('employees.csv')

print("\n--- Basic DataFrame Information ---")
print(f"Shape (rows, columns): {df.shape}")
print(f"Column names: {list(df.columns)}")
print(f"Data types:\n{df.dtypes}")


print("\n--- First 3 rows (df.head(3)) ---")
print(df.head(3))

print("\n--- Basic Statistics (df.decribe()) ---")
print(df.describe())

# Section 6: Handling different CSV Formats


print("\n" + "=" * 80)
print("Section 4: Handling different CSV Formats")
print("=" * 80)



# CSV with different delimiter (semicolon instead of comma)
semicolon_csv = """name;age;country
Alice;25;USA
Bob;30;UK
Charlie;35;Canada"""


with open('semicolon_data.csv', 'w') as f:
  f.write(semicolon_csv)


# Read with custom delimiter
df_semicolon = pd.read_csv('semicolon_data.csv', delimiter=';')
print("\n--- CSV with semicolon delimiter ---")
print(df_semicolon)

# CSV without headers
no_header_csv = """John,25,Engineer
Jane,30,Doctor
Jim,28,Teacher"""

with open('no_header.csv', 'w') as f:
  f.write(no_header_csv)


# Read CSV without headers and assign column names
df_no_header = pd.read_csv('no_header.csv',
                           header=None,
                           names=['Name', 'Age', 'Profession'])
print("\n--- CSV without headers (manually assigned) ---")
print(df_no_header)

# CSV with missing values
missing_csv = """name,age,city
John,28,New York
ALice,,San Francisco
Bob,45,"""

with open('missing_data.csv', 'w') as f:
  f.write(missing_csv)

df_missing = pd.read_csv('missing_data.csv')
print("\n--- CSV with missing values (shown as Nan) ---")
print(df_missing)

# Section 7: Data operations and manipulations

print("\n" + "=" * 80)
print("Section 5: Data Operations and Manipulations")
print("=" * 80)


# Reload main dataset

df = pd.read_csv('employees.csv')


# 1. Selecting columns
print("\n--- Selecting specific columns ---")
print(df[['name', 'salary']].head(3))

# 2. Filtering rows based on conditions
print("\n--- Multiple conditions: Age < 35 AND department = Engineering ---")
young_engineers = df[(df['age'] < 35) & (df['department'] == 'Engineering')]
print(young_engineers)

# Sorting data
print("\n--- Sorting by salary (descending) ---")
print(df.sort_values('salary', ascending=False))

# Adding new columns (calculated)
print("\n--- Adding calculated column (annual_bonus = salary * 0.1) ---")
df['annual_bonus'] = df['salary'] * 0.1
print(df[['name', 'salary', 'annual_bonus']].head(3))

# Grouping and aggregating
print("\n--- Group by department and calculate average salary ---")
dept_avg = df.groupby('department')['salary'].mean()
print(dept_avg)

# Counting values
print("\n--- Count employees by department ---")
print(df['department'].value_counts())

# Finding unique values
print("\n-- Unique cities ---")
print(df['city'].unique())

# Basic statistics per column
print("\n--- Salary statistics ---")
print(f"Mean salary: ${df['salary'].mean():,.2f}")
print(f"Median salary: ${df['salary'].median():,.2f}")
print(f"Min salary: ${df['salary'].min():,.2f}")
print(f"Max salary: ${df['salary'].max():,.2f}")

# Acessing specific cell values
print("\n--- Acessing specific cells ---")
print(f"First employee's name: {df.loc[0, 'name']}")
print(f"Salary at row 2: ${df.iloc[2]['salary']:,}")

# Section 8: Handling missing data

print("\n" + "=" * 80)
print("Section 6: Handling Missing Data")
print("=" * 80)


df_missing = pd.read_csv('missing_data.csv')

print("\n--- Original data with missing values ---")
print(df_missing)

print("\n--- Checking for missing values ---")
print(df_missing.isnull().sum())

# Option 1: Drop rows with any missing values
print("\n--- Drop rows with missing values ---")
df_dropped = df_missing.dropna()
print(df_dropped)

# Option 2: Fill missing values with a default
print("\n Fill missing values with a defaults ---")
df_filled = df_missing.fillna({'age': 0, 'city': 'Unknown'})
print(df_filled)

# Option 3: Fill with mean/median for numerical columns
df_missing_copy = df_missing.copy()
df_missing_copy['age'] = df_missing_copy['age'].fillna(df_missing_copy['age'].mean())
print("\n--- Fill missing age with mean age ---")
print(df_missing_copy)

# Section 9: Writng/Saving CSV Files

print("\n" + "=" * 80)
print("Section 7: Writing/Saving CSV Files")
print("=" * 80)


# Create a new DataFrame
new_data = pd.DataFrame({
    'product': ['Laptop', 'Phone', 'Tablet', 'Monitor'],
    'price': [1200, 800, 500, 350],
    'stock': [15, 30, 25, 40]
})


# Save to CSV
new_data.to_csv('products.csv', index=False)
print("Saved products.csv (without index)")

# Save with custom seperator
new_data.to_csv('products_semicolon.csv', index=False, sep=';')
print("Saved products_semicolon.csv (semicolon seperator)")


# Save only specific columns
new_data[['product', 'price']].to_csv('products_simple.csv', index=False)
print("Saved products_simple.csv (only two columns)")

# Append to existing CSV (requires special handling)
additional_products = pd.DataFrame({
    'product': ['Keyboard'],
    'price': [75],
    'stock': [50]
})

# Open in append mode
with open('products.csv', 'a') as f:
  additional_products.to_csv(f, header=False, index=False)
print("Appended new row to products.csv")

# Using csv module  to write
print("\n--- Writing with csv module ---")
with open('manual_write.csv', 'w', newline='') as f:
  writer = csv.writer(f)

  # Write header
  writer.writerow(['Name', 'Score', 'Grade'])

  # Write data rows
  writer.writerow(['Alice', 95, 'A'])
  writer.writerow(['Bob', 87, 'B'])
  writer.writerow(['Charlie', 92, 'A'])


print("Created manual_write.csv using csv.writer")